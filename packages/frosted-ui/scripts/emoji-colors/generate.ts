import emojiData from 'emoji-datasource/emoji.json';
import * as fs from 'fs';
import * as path from 'path';
import { getDominantColor, getWeightedDominantColor } from './utils/color-extractor';
import { findClosestColorScale, isGrayscale, type ColorScale } from './utils/color-matcher';
import { renderEmojiAndExtractColors } from './utils/emoji-renderer';

interface EmojiEntry {
  unified: string;
  name: string;
  category: string;
  short_name: string;
  has_img_apple: boolean;
  has_img_google: boolean;
  obsoleted_by?: string;
  skin_variations?: Record<string, unknown>;
}

/**
 * Converts Unicode codepoint string to emoji character
 */
function unifiedToEmoji(unified: string): string {
  return unified
    .split('-')
    .map((hex) => String.fromCodePoint(parseInt(hex, 16)))
    .join('');
}

/**
 * Filters emoji data to get only fully-qualified emojis
 */
function getEmojiList(): Array<{ emoji: string; name: string }> {
  const emojis: Array<{ emoji: string; name: string }> = [];

  for (const entry of emojiData as EmojiEntry[]) {
    // Skip if obsoleted by another emoji
    if (entry.obsoleted_by) {
      continue;
    }

    // Only include emojis with Apple images (generally well-supported)
    if (!entry.has_img_apple) {
      continue;
    }

    const emoji = unifiedToEmoji(entry.unified);
    emojis.push({
      emoji,
      name: entry.name || entry.short_name,
    });

    // Note: We're excluding skin tone variations for now
    // They can inherit the base emoji's color
  }

  return emojis;
}

/**
 * Processes a single emoji and returns its color scale
 */
function processEmoji(emoji: string, name: string): ColorScale {
  try {
    // Extract colors from emoji
    const colors = renderEmojiAndExtractColors(emoji);

    if (colors.length === 0) {
      console.warn(`No colors extracted for ${emoji} (${name}), defaulting to gray`);
      return 'gray';
    }

    // Get dominant color using weighted approach (prefers saturated colors)
    let dominantColor = getWeightedDominantColor(colors);

    // Fallback to simple dominant color if weighted fails
    if (!dominantColor) {
      dominantColor = getDominantColor(colors);
    }

    if (!dominantColor) {
      console.warn(`Failed to extract dominant color for ${emoji} (${name}), defaulting to gray`);
      return 'gray';
    }

    // If color is grayscale, return gray
    if (isGrayscale(dominantColor)) {
      return 'gray';
    }

    // Find closest color scale
    const colorScale = findClosestColorScale(dominantColor);
    return colorScale;
  } catch (error) {
    console.error(`Error processing ${emoji} (${name}):`, error);
    return 'gray';
  }
}

/**
 * Main generation function
 */
async function generateEmojiColors() {
  console.log('üé® Starting emoji color generation...\n');

  const emojis = getEmojiList();
  console.log(`üìä Processing ${emojis.length} emojis...\n`);

  const emojiColorMap: Record<string, ColorScale> = {};
  const stats: Record<ColorScale, number> = {} as Record<ColorScale, number>;

  let processed = 0;
  for (const { emoji, name } of emojis) {
    const colorScale = processEmoji(emoji, name);
    emojiColorMap[emoji] = colorScale;

    // Update stats
    stats[colorScale] = (stats[colorScale] || 0) + 1;

    processed++;
    if (processed % 100 === 0) {
      console.log(`Processed ${processed}/${emojis.length} emojis...`);
    }
  }

  console.log(`\n‚úÖ Processed all ${processed} emojis!\n`);

  // Print statistics
  console.log('üìà Color distribution:');
  const sortedStats = Object.entries(stats).sort((a, b) => b[1] - a[1]);
  for (const [color, count] of sortedStats) {
    const percentage = ((count / processed) * 100).toFixed(1);
    console.log(`  ${color.padEnd(10)} ${count.toString().padStart(4)} (${percentage}%)`);
  }

  // Generate TypeScript file
  const outputPath = path.join(__dirname, '../../src/helpers/emoji-colors.ts');

  const fileContent = `// This file is auto-generated by scripts/emoji-colors/generate.ts
// Do not edit manually. Run \`pnpm generate:emoji-colors\` to regenerate.
// Generated on: ${new Date().toISOString()}
// Total emojis: ${processed}

import type { radixColorScales } from './radix-colors';

export type ColorScale = (typeof radixColorScales)[number] | 'gray';

/**
 * Maps emojis to their corresponding color scale in the Frosted UI color system.
 * The color is determined by analyzing the dominant color of the emoji and matching
 * it to the closest color-9 shade in our color palette.
 */
export const emojiColorMap: Record<string, ColorScale> = ${JSON.stringify(emojiColorMap, null, 2)};

/**
 * Gets the color scale for a given emoji.
 * Returns 'gray' as fallback if the emoji is not found.
 */
export function getColorForEmoji(emoji: string): ColorScale {
  return emojiColorMap[emoji] || 'gray';
}
`;

  fs.writeFileSync(outputPath, fileContent, 'utf-8');
  console.log(`\nüíæ Saved emoji color map to: ${outputPath}`);
  console.log(`üì¶ File size: ${(fs.statSync(outputPath).size / 1024).toFixed(2)} KB\n`);

  console.log('üéâ Done!\n');
}

// Run the script
generateEmojiColors().catch((error) => {
  console.error('‚ùå Error:', error);
  process.exit(1);
});
